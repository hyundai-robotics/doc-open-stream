## 2. Session and Streaming Rules

<div style="fit-content;">

{% hint style="info" %}

This document explains the <b>Session Lifecycle</b> and <b>Streaming Behavior</b>  
that must be understood to properly implement and operate Open Stream.

{% endhint %}

</div>

<br>

<h4 style="font-size:16px; font-weight:bold;">1. Session Lifecycle</h4>

Open Stream treats <b>one TCP connection as one session</b>.  
A typical session flow is as follows:

1. The client connects to the server over TCP to create a session.
2. Immediately after connection, the client sends the `HANDSHAKE` command to verify protocol version compatibility with the server.
3. After processing the `HANDSHAKE` request, if the protocol version matches, the server sends a `handshake_ack` event.
4. After `HANDSHAKE`, the client can request periodic data streaming via `MONITOR`, or execute one-shot requests via `CONTROL`. (`CONTROL` can also be sent while `MONITOR` is active.)
5. When `MONITOR` is active, the server sends `data` events periodically regardless of additional client requests.
6. A `CONTROL` command sends no separate ACK on success; only on failure may an `error` or `control_err` event be delivered.
7. When work is complete, the client sends `STOP` to indicate termination intent for the active operation or session, then closes the TCP connection after receiving `stop_ack` from the server.

{% hint style="warning" %}

Open Stream is an event-driven streaming protocol and does not guarantee request-response ordering.  
Since the arrival order between `data`, `*_ack`, and `error` events is not guaranteed, clients must handle events without relying on message order.

{% endhint %}


<br>

<h4 style="font-size:16px; font-weight:bold;">2. Usage Rules</h4>

The following rules must be followed to use Open Stream correctly.

- `HANDSHAKE` must be performed <b>at the beginning of the session</b>.
- If `MONITOR` or `CONTROL` is called before `HANDSHAKE`, the server may reject the request.
- `STOP(target=session)` is used to explicitly indicate "graceful termination intent," and it is recommended to close the TCP connection afterward.

<br>
<h4 style="font-size:16px; font-weight:bold;">3. Message Direction</h4>

<p>
Messages used in Open Stream are categorized as follows based on <b>direction and role</b>.
</p>

<div style="display:flex; flex-wrap:wrap; gap:16px; align-items:flex-start;">

  <!-- Left: Diagram -->
  <div style="flex:1 1 430px; min-width:280px; max-width:430px;">
    <img
      src="../_assets/2-open_stream_message_direction.png"
      alt="open stream message flow chart"
      style="max-width:100%; height:auto;"
    />
  </div>

  <!-- Right: Two tables -->
<div style="flex:1 1 520px; min-width:280px; max-width:fit-content; display:flex; flex-direction:column; gap:12px;">

  <div style="overflow-x:auto;">
    <div style="font-weight:bold; margin-bottom:6px;">Client → Server (Commands)</div>
    <table style="width:fit-content; min-width:fit-content; border-collapse:collapse;">
      <thead>
        <tr>
          <th>Command</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
        <tr><td><code>HANDSHAKE</code></td><td>Protocol version negotiation</td></tr>
        <tr><td><code>MONITOR</code></td><td>Configure periodic data streaming</td></tr>
        <tr><td><code>CONTROL</code></td><td>Execute command-type REST requests</td></tr>
        <tr><td><code>STOP</code></td><td>Terminate active operation or session</td></tr>
      </tbody>
    </table>
  </div>

  <div style="overflow-x:auto;">
    <div style="font-weight:bold; margin-bottom:6px;">Client ⇠ Server (Events)</div>
    <table style="width:fit-content; min-width:fit-content; border-collapse:collapse;">
      <thead>
        <tr>
          <th>Event</th>
          <th>Description</th>
          <th>Notes</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>*_ack</code></td>
          <td>ACK indicating that a command has been accepted</td>
          <td>e.g. <code>handshake_ack</code>, <code>monitor_ack</code>, <code>stop_ack</code></td>
        </tr>
        <tr>
          <td><code>data</code></td>
          <td>Periodic data event while MONITOR is active</td>
          <td>Result of executing the ${cont_model} Open API service function</td>
        </tr>
        <tr>
          <td><code>error</code></td>
          <td>Error message delivered when a failure occurs</td>
          <td>Refer to the Error Codes section for details</td>
        </tr>
      </tbody>
    </table>
  </div>

  {% hint style="info" %}

  Server → Client events may <b>not correspond 1:1 with client</b> requests.  
  While `*_ack` and `error` follow a request-response pattern,  
  `data` events generated by MONITOR are streamed independently.  
  The client must always keep the receive loop running.

  {% endhint %}
  
</div>
</div>

<div style="max-width:fit-content;">


| Request-Response | Streaming |
|---|---|
| Client → `HANDSHAKE/MONITOR/CONTROL/STOP` → Server<br>Client ← `*_ack`, `error` ← Server | (after `monitor_ack`)<br>Server → `data` → Client<br>Server → `data` → Client<br>... |
</div>

<br>
<h4 style="font-size:16px; font-weight:bold;">4. MONITOR Streaming Behavior</h4>

`MONITOR` is a server-driven mechanism where, based on the recipe provided by the client,  
the server executes the ${cont_model} Open API service function at the specified interval (`period_ms`)  
and streams the result as `data` events.

Clients must be implemented with the following assumptions.

- Always keep the receive loop running.
- Do not assume synchronous request-response pairing.

<br>
<h4 style="font-size:16px; font-weight:bold;">5. CONTROL Command Execution</h4>


Depending on policy/implementation, <b>CONTROL provides no separate response line on success.</b>

Recommended strategy:

- Detect failures via `error` or `control_err` events.
- Verify success using the following approaches:
  - Confirm changes in MONITOR results
  - Use a dedicated state-query MONITOR endpoint


<br>
<h4 style="font-size:16px; font-weight:bold;">6. Timeout / Watchdog</h4>

The server may terminate the connection if the session remains idle for an extended period.

Client recommendations:

- Perform `HANDSHAKE` immediately after connection
- Perform a graceful shutdown using `STOP(target=session)`
- Prevent the receive loop from stopping during streaming
- Prepare reconnection and re-HANDSHAKE logic on EOF or socket errors

In the current server implementation, the following policies apply.

- <b>Disarmed state (Idle / No active MONITOR)</b>  
  &rightarrow; Session is terminated after approximately <b>180 seconds</b> of no meaningful activity

- <b>Armed state (Active MONITOR streaming)</b>  
  &rightarrow; Session is terminated if streaming remains interrupted for more than approximately <b>5 seconds</b>

* The above time values may change depending on server policy or operating environment.

<br>
<h4 style="font-size:16px; font-weight:bold;">7. Recommended Architecture </h4>

For practical implementations, the following structure is recommended.

- Separate sending (Commands) and receiving (Events)  
  &rightarrow; Send: build command + `sendall`  
  &rightarrow; Receive: NDJSON line parser + dispatcher

- Single-responsibility receive loop  
  &rightarrow; Split lines by `\n`  
  &rightarrow; JSON parsing  
  &rightarrow; Event routing based on `type` / `error`
